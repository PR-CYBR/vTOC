name: Project backlog plan

on:
  projects_v2_item:
    types:
      - created
      - edited

permissions:
  contents: write
  pull-requests: read
  projects: write

jobs:
  plan:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PROJECTS_TOKEN: ${{ secrets.PROJECTS_WORKFLOW_TOKEN != '' && secrets.PROJECTS_WORKFLOW_TOKEN || secrets.GITHUB_TOKEN }}
    steps:
      - name: Check Codex required configuration
        shell: bash
        run: |
          missing=0
          for var in CODEX_API_KEY CODEX_BASE_URL; do
            if [ -z "${!var}" ]; then
              echo "::warning::$var is not set. Skipping Codex-driven automation."
              missing=1
            fi
          done
          if [ "$missing" -eq 1 ]; then
            exit 0
          fi
        env:
          CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
          CODEX_BASE_URL: ${{ vars.CODEX_BASE_URL }}
      
      - name: Gather project item metadata
        id: metadata
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.PROJECTS_TOKEN }}
          script: |
            const item = context.payload.projects_v2_item;
            if (!item) {
              core.info('No project item in payload.');
              core.setOutput('run', 'false');
              return;
            }

            const itemNodeId = item.node_id;
            if (!itemNodeId) {
              core.info('Project item is missing a node ID.');
              core.setOutput('run', 'false');
              return;
            }

            const query = `
              query($itemId: ID!) {
                node(id: $itemId) {
                  ... on ProjectV2Item {
                    id
                    project {
                      id
                      number
                      title
                      url
                      fields(first: 50) {
                        nodes {
                          __typename
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                    fieldValues(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2ItemFieldSingleSelectValue {
                          name
                          optionId
                          field {
                            ... on ProjectV2SingleSelectField {
                              name
                            }
                          }
                        }
                        ... on ProjectV2ItemFieldTextValue {
                          text
                          field {
                            ... on ProjectV2FieldCommon {
                              name
                            }
                          }
                        }
                        ... on ProjectV2ItemFieldNumberValue {
                          number
                          field {
                            ... on ProjectV2FieldCommon {
                              name
                            }
                          }
                        }
                        ... on ProjectV2ItemFieldDateValue {
                          date
                          field {
                            ... on ProjectV2FieldCommon {
                              name
                            }
                          }
                        }
                        ... on ProjectV2ItemFieldIterationValue {
                          title
                          startDate
                          duration
                          field {
                            ... on ProjectV2IterationField {
                              name
                            }
                          }
                        }
                      }
                    }
                    content {
                      __typename
                      ... on DraftIssue {
                        title
                        body
                      }
                      ... on Issue {
                        title
                        body
                        number
                        url
                      }
                      ... on PullRequest {
                        title
                        body
                        number
                        url
                        headRefName
                      }
                    }
                  }
                }
              }
            `;

            const { node } = await github.graphql(query, { itemId: itemNodeId });
            if (!node) {
              core.info(`Unable to find project item with node ID ${itemNodeId}.`);
              core.setOutput('run', 'false');
              return;
            }

            const project = node.project;
            if (!project) {
              core.info('Project item is not attached to a project.');
              core.setOutput('run', 'false');
              return;
            }

            const fieldValues = node.fieldValues?.nodes ?? [];
            const statusValue = fieldValues.find((value) => {
              if (value?.__typename !== 'ProjectV2ItemFieldSingleSelectValue') {
                return false;
              }
              const field = value.field;
              return field?.name === 'Status';
            });

            const statusName = statusValue?.name ?? '';
            const shouldRun = statusName === 'Backlog';
            core.setOutput('run', shouldRun ? 'true' : 'false');
            if (!shouldRun) {
              core.info(`Skipping project item ${item.id} because status is '${statusName}'.`);
              return;
            }

            const statusField = project.fields?.nodes?.find((field) => {
              return field?.__typename === 'ProjectV2SingleSelectField' && field?.name === 'Status';
            });

            const readyOption = statusField?.options?.find((option) => option?.name === 'Ready');
            if (!statusField || !readyOption) {
              core.setFailed('Unable to resolve the Ready status option for the project.');
              return;
            }

            const fieldSummaries = fieldValues.map((value) => {
              const base = {
                type: value?.__typename,
              };

              if (value?.field?.name) {
                base.field = value.field.name;
              }

              if (value?.text) {
                base.value = value.text;
              } else if (value?.name) {
                base.value = value.name;
              } else if (typeof value?.number === 'number') {
                base.value = value.number;
              } else if (value?.date) {
                base.value = value.date;
              } else if (value?.title) {
                base.value = value.title;
              }

              if (value?.optionId) {
                base.optionId = value.optionId;
              }

              return base;
            });

            const normaliseFeature = (raw) => {
              if (!raw) {
                return '';
              }
              return raw
                .toString()
                .trim()
                .toLowerCase()
                .replace(/[^a-z0-9/_-]+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
            };

            const featureFieldCandidates = [
              'spec feature',
              'feature',
              'feature directory',
              'feature slug',
              'feature branch',
              'branch',
              'target branch',
            ];

            let rawFeature = '';
            for (const value of fieldValues) {
              const fieldName = (value?.field?.name || '').toLowerCase().trim();
              if (!fieldName || !featureFieldCandidates.includes(fieldName)) {
                continue;
              }
              const candidates = [];
              if (typeof value?.text === 'string') candidates.push(value.text);
              if (typeof value?.name === 'string') candidates.push(value.name);
              if (typeof value?.title === 'string') candidates.push(value.title);
              if (typeof value?.number === 'number') candidates.push(String(value.number));
              if (typeof value?.date === 'string') candidates.push(value.date);
              for (const candidate of candidates) {
                if (candidate && candidate.toString().trim()) {
                  rawFeature = candidate.toString().trim();
                  break;
                }
              }
              if (rawFeature) {
                break;
              }
            }

            if (!rawFeature && node.content?.__typename === 'PullRequest') {
              rawFeature = node.content.headRefName || '';
            }
            const specFeature = normaliseFeature(rawFeature);

            const content = node.content;
            let contentData = null;
            if (content) {
              contentData = {
                type: content.__typename,
                title: content.title ?? null,
                body: content.body ?? null,
              };

              if (typeof content.number !== 'undefined') {
                contentData.number = content.number;
              }

              if (content.url) {
                contentData.url = content.url;
              }
            }

            const contextData = {
              project_item_id: item.id ?? itemNodeId,
              project_item_node_id: node.id,
              project: {
                id: project.id,
                number: project.number,
                title: project.title,
                url: project.url,
              },
              status: statusName,
              field_values: fieldSummaries,
              content: contentData,
              spec: {
                feature: specFeature || null,
                raw_feature: rawFeature || null,
              },
            };

            core.setOutput('spec_feature', specFeature || '');

            const base64Context = Buffer.from(JSON.stringify(contextData)).toString('base64');
            core.setOutput('context_base64', base64Context);
            core.setOutput('project_item_id', item.id ?? itemNodeId);
            core.setOutput('project_item_node_id', node.id);
            core.setOutput('status_field_id', statusField.id);
            core.setOutput('ready_option_id', readyOption.id);
            core.setOutput('project_id', project.id);

      - name: Check out repository
        if: steps.metadata.outputs.run == 'true'
        uses: actions/checkout@v4

      - name: Prepare backlog workspace
        if: steps.metadata.outputs.run == 'true'
        run: |
          set -euo pipefail
          mkdir -p backlog

      - name: Write backlog context
        if: steps.metadata.outputs.run == 'true'
        env:
          BACKLOG_CONTEXT_BASE64: ${{ steps.metadata.outputs.context_base64 }}
        run: |
          set -euo pipefail
          python - <<'PY'
          import base64
          import os
          from pathlib import Path

          context_base64 = os.environ["BACKLOG_CONTEXT_BASE64"]
          context_path = Path("backlog/context.json")
          context_path.parent.mkdir(parents=True, exist_ok=True)
          context_path.write_bytes(base64.b64decode(context_base64))
          PY

      - name: Set up Python
        if: steps.metadata.outputs.run == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install planning dependencies
        if: steps.metadata.outputs.run == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install PyYAML

      - name: Setup Codex CLI
        if: steps.metadata.outputs.run == 'true'
        shell: bash
        env:
          LOGURU_AUTOINIT: "0"
          PYTHONUNBUFFERED: "1"
          PATH: ${{ runner.temp }}/.local/bin:${{ env.PATH }}
        run: |
          pipx install codex
          which codex
          codex --version

      - name: Generate Codex plan (one-shot mode)
        if: steps.metadata.outputs.run == 'true'
        id: plan
        shell: bash
        env:
          SPECIFY_FEATURE: ${{ steps.metadata.outputs.spec_feature }}
          LOGURU_AUTOINIT: "0"
          PYTHONUNBUFFERED: "1"
          PATH: ${{ runner.temp }}/.local/bin:${{ env.PATH }}
          CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
          CODEX_BASE_URL: ${{ vars.CODEX_BASE_URL }}
        run: |
          # Use codex cloud tasks plan in one-shot mode via Python script
          python scripts/automation/backlog_plan.py \
            --context backlog/context.json \
            --backlog-file backlog/backlog.yaml \
            --skip-if-exists \
            --result backlog/plan-result.json > codex_plan.log 2>&1 || { 
            echo "Codex plan generation failed â€” dumping log:" 
            cat codex_plan.log 
            exit 1 
          }

      - name: Sync Spec Kit tasks
        if: steps.metadata.outputs.run == 'true'
        env:
          SPECIFY_FEATURE: ${{ steps.metadata.outputs.spec_feature }}
        run: |
          set -euo pipefail
          python -m scripts.bootstrap_cli spec sync \
            --plan-result backlog/plan-result.json

      - name: Capture plan result
        if: steps.metadata.outputs.run == 'true'
        id: plan_result
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'backlog/plan-result.json';
            let raw = '';
            let skipped = false;
            let planUrl = '';
            if (fs.existsSync(path)) {
              try {
                raw = fs.readFileSync(path, 'utf8');
                const data = JSON.parse(raw || '{}');
                skipped = !!data.skipped;
                planUrl = data.plan_url || '';
              } catch (error) {
                core.warning(`Failed to read plan result: ${error}`);
              }
            } else {
              core.warning(`${path} was not generated.`);
            }
            core.setOutput('raw', raw);
            core.setOutput('skipped', skipped ? 'true' : 'false');
            core.setOutput('plan_url', planUrl);

      - name: Commit backlog plan
        if: steps.metadata.outputs.run == 'true' && steps.plan_result.outputs.skipped != 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: record Codex plan for project item ${{ steps.metadata.outputs.project_item_id }}"
          file_pattern: |
            backlog/backlog.yaml
            specs/**/tasks.md

      - name: Move project item to Ready
        if: steps.metadata.outputs.run == 'true' && steps.plan_result.outputs.skipped != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.PROJECTS_TOKEN }}
          script: |
            const projectId = '${{ steps.metadata.outputs.project_id }}';
            const itemId = '${{ steps.metadata.outputs.project_item_node_id }}';
            const fieldId = '${{ steps.metadata.outputs.status_field_id }}';
            const optionId = '${{ steps.metadata.outputs.ready_option_id }}';

            if (!projectId || !itemId || !fieldId || !optionId) {
              core.setFailed('Missing identifiers required to move the project item to Ready.');
              return;
            }

            await github.graphql(
              `mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(
                  input: {
                    projectId: $projectId,
                    itemId: $itemId,
                    fieldId: $fieldId,
                    value: { singleSelectOptionId: $optionId }
                  }
                ) {
                  projectV2Item { id }
                }
              }`,
              {
                projectId,
                itemId,
                fieldId,
                optionId,
              },
            );

            core.info(`Moved project item ${itemId} to Ready.`);

      - name: Clean up temporary files
        if: steps.metadata.outputs.run == 'true'
        run: |
          set -euo pipefail
          rm -f backlog/context.json backlog/plan-result.json
